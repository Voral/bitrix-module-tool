<?php

declare(strict_types=1);

namespace Voral\BitrixModuleTool\Tests;

use PHPUnit\Framework\TestCase;
use Vasoft\VersionIncrement\Commits\CommitCollection;
use Vasoft\VersionIncrement\Commits\Section;
use Vasoft\VersionIncrement\Config;
use Vasoft\VersionIncrement\Contract\VcsExecutorInterface;
use Vasoft\VersionIncrement\Events\Event;
use Vasoft\VersionIncrement\Events\EventType;
use Vasoft\VersionIncrement\SectionRules\DefaultRule;
use Vasoft\VersionIncrement\SemanticVersionUpdater;
use Voral\BitrixModuleTool\Exception\ExtensionException;
use Voral\BitrixModuleTool\Exception\InvalidPathException;
use Voral\BitrixModuleTool\Exception\NotAccessibleException;
use Voral\BitrixModuleTool\Exception\NoVersionTagException;
use Voral\BitrixModuleTool\Exception\WrongVersionFileException;
use Voral\BitrixModuleTool\ModuleListener;
use Vasoft\VersionIncrement\Exceptions\ApplicationException;
use PHPUnit\Framework\MockObject\Exception;

include_once __DIR__ . '/MockTrait.php';

/**
 * @internal
 *
 * @coversDefaultClass  \Voral\BitrixModuleTool\ModuleListener
 *
 * @covers \Voral\BitrixModuleTool\Exception\ExtensionException
 * @covers \Voral\BitrixModuleTool\Exception\NotAccessibleException
 * @covers \Voral\BitrixModuleTool\Exception\NoVersionTagException
 * @covers \Voral\BitrixModuleTool\Exception\WrongVersionFileException
 * @covers \Voral\BitrixModuleTool\ModuleListener
 */
final class ModuleListenerTest extends TestCase
{
    use MockTrait;

    private static string $destDir = __DIR__ . '/fake/dst/';

    public static function setUpBeforeClass(): void
    {
        parent::setUpBeforeClass(); // TODO: Change the autogenerated stub
        if (!is_dir(self::$destDir)) {
            mkdir(self::$destDir, 0o775, true);
        }
    }

    protected function setUp(): void
    {
        ExtensionException::$errorCodeDelta = 0;
        $this->initMocks($this->fail(...), 'Voral\BitrixModuleTool');
    }

    /**
     * @throws ExtensionException
     *
     * @covers ::getProjectPath
     *
     * @dataProvider provideProjectPathNotAccessibleCases
     */
    public function testProjectPathNotAccessible(int $codeDelta): void
    {
        ExtensionException::$errorCodeDelta = $codeDelta;
        $this->clearMockGetEnv(['COMPOSER' => false]);
        $this->clearMockGetCwd([false]);
        $this->clearMockRealPath([], 'Should not run the command realpath');

        self::expectException(NotAccessibleException::class);
        self::expectExceptionMessage('Unable to determine project path: current working directory is not accessible.');
        self::expectExceptionCode(5101 + $codeDelta);
        new ModuleListener(new Config(), 'vendor.test');
    }

    public static function provideProjectPathNotAccessibleCases(): iterable
    {
        yield [0];
        yield [200];
    }

    /**
     * @throws ExtensionException
     *
     * @covers ::getProjectPath
     * @covers ::handle
     * @covers       \Voral\BitrixModuleTool\Exception\InvalidPathException
     *
     * @dataProvider provideProjectPathNotAccessibleCases
     */
    public function testProjectInvalid(int $codeDelta): void
    {
        ExtensionException::$errorCodeDelta = $codeDelta;
        $this->clearMockGetEnv(['COMPOSER' => false]);
        $this->clearMockGetCwd(['/home/project']);
        $this->clearMockRealPath([], '');

        self::expectException(InvalidPathException::class);
        self::expectExceptionMessage('Unable to determine project path: the resolved path "/home/project" is invalid.');
        self::expectExceptionCode(5102 + $codeDelta);
        new ModuleListener(new Config(), 'vendor.test');
    }

    /**
     * @throws ApplicationException
     * @throws Exception
     * @throws ExtensionException
     *
     * @covers ::handle
     */
    public function testNotExistsTag(): void
    {
        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockFileExists([false]);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $config = new Config();
        $event = self::createMock(Event::class);
        $event->expects(self::exactly(1))->method('getData')
            ->willReturn(null);

        $listener = new ModuleListener($config, 'vendor.test');
        self::expectException(NoVersionTagException::class);
        self::expectExceptionMessage('No version tag found.');
        self::expectExceptionCode(5103);
        $listener->handle($event);
    }

    /**
     * @throws ExtensionException
     * @throws ApplicationException
     *
     * @dataProvider provideWrongVersionFileContentCases
     *
     * @covers ::handle
     */
    public function testWrongVersionFileContent(false|string $content): void
    {
        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $this->clearMockFileExists([
            '/home/project/last_version/install/version.php' => true,
        ]);
        $this->clearMockFileGetContents([
            '/home/project/last_version/install/version.php' => $content,
        ]);


        $config = new Config();
        //        $gitExecutor = self::createMock(VcsExecutorInterface::class);
        //        $gitExecutor->expects(self::never())->method('addFile');
        //        $gitExecutor->expects(self::never())->method('getFilesSinceTag');

        $event = $this->getMockBuilder(Event::class)
            ->setConstructorArgs([EventType::BEFORE_VERSION_SET, '1.1.0'])
            ->getMock();
        $event->expects(self::exactly(1))->method('getData')
            ->willReturnCallback(static function (string $key): string {
                return match ($key) {
                    SemanticVersionUpdater::LAST_VERSION_TAG => 'v1.0.0',
                    SemanticVersionUpdater::COMMIT_LIST => $this->getCommitCollection(),
                    default => '',
                };
            });

        $listener = new ModuleListener($config, 'vendor.test');
        self::expectException(WrongVersionFileException::class);
        self::expectExceptionMessage('Wrong version file format.');
        self::expectExceptionCode(5104);
        $listener->handle($event);
    }

    public static function provideWrongVersionFileContentCases(): iterable
    {
        yield [false];
        yield [''];
        yield [
            <<<'PHP'
                $arModuleVersion = [
                    'VERSION' => '1.0.0',
                ];
                PHP,
        ];
        yield [
            <<<'PHP'
                $arModuleVersion = [
                    'VERSION_DATE' => '2022-01-01',
                ];
                PHP,
        ];
    }

    /**
     * @throws ApplicationException
     * @throws ExtensionException
     * @throws Exception
     *
     * @covers ::__construct
     * @covers ::controlPhpVersion
     * @covers ::copyFilesWithStructure
     * @covers ::getCopyDirectories
     * @covers ::getProjectPath
     * @covers ::getRemoveFiles
     * @covers ::handle
     * @covers ::updateModuleVersion
     * @covers ::writeDescription
     * @covers ::writeUpdater
     * @covers ::writeVersionControl
     */
    public function testSingleEmptyCommitList(): void
    {
        $this->clearMockDirName(
            ['/home/project/last_version/install/version.php' => '/home/project/last_version/install'],
        );
        $this->clearMockIsDir(['/home/project/updates/1.1.0/install' => false]);
        $this->clearMockIsFile(['/home/project/last_version/install/version.php' => true]);

        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $this->clearMockFileExists([
            '/home/project/last_version/install/version.php' => true,
        ]);
        $this->clearMockFileGetContents([
            '/home/project/last_version/install/version.php' => <<<'PHP'
                <?php
                $arModuleVersion = [
                    'VERSION' => '1.0.0',
                    'VERSION_DATE' => '2022-01-01',
                ];
                PHP,
        ]);
        $this->clearMockFilePutContents();
        $addedFiles = [];
        $gitExecutor = self::createMock(VcsExecutorInterface::class);
        $gitExecutor->expects(self::exactly(3))
            ->method('addFile')
            ->willReturnCallback(static function (string $fileName) use (&$addedFiles): void {
                $addedFiles[] = $fileName;
            });
        $gitExecutor->expects(self::once())->method('getFilesSinceTag')
            ->willReturn([]);
        $config = new Config();
        $config->setVcsExecutor($gitExecutor);

        $event = $this->getMockBuilder(Event::class)
            ->setConstructorArgs([EventType::BEFORE_VERSION_SET, '1.1.0'])
            ->getMock();
        $event->expects(self::exactly(2))->method('getData')
            ->willReturnCallback(static function (string $key): mixed {
                return match ($key) {
                    SemanticVersionUpdater::LAST_VERSION_TAG => 'v1.0.0',
                    SemanticVersionUpdater::COMMIT_LIST => self::getCommitCollection(),
                    default => '',
                };
            });

        $listener = new ModuleListener($config, 'vendor.test');
        $listener->handle($event);
        $date = date('Y-m-d');
        self::assertSame(
            <<<PHP
                <?php
                \$arModuleVersion = [
                    'VERSION' => '1.1.0',
                    'VERSION_DATE' => '{$date}',
                ];
                PHP,
            self::$mockFilePutContentsContent['/home/project/last_version/install/version.php'],
            'Wrong version file content',
        );
        self::assertSame(
            ['/home/project/last_version/install/version.php'],
            array_keys(self::$mockCopyParam),
            'Wrong copy files',
        );

        self::assertSame([
            '/home/project/updates/1.1.0/updater1.1.0.php',
            '/home/project/updates/1.1.0/description.ru',
            '/home/project/updates/1.1.0/description.en',
        ], $addedFiles, 'Wrong files added to git');
        self::assertSame(
            <<<'PHP'
                <?php

                declare(strict_types=1);

                /**
                * @var CUpdater $updater
                */



                PHP,
            self::$mockFilePutContentsContent['/home/project/updates/1.1.0/updater1.1.0.php'],
            'Wrong updater file content',
        );
        self::assertSame('', self::$mockFilePutContentsContent['/home/project/updates/1.1.0/description.ru']);
        self::assertSame('', self::$mockFilePutContentsContent['/home/project/updates/1.1.0/description.en']);
    }

    /**
     * @throws ApplicationException
     * @throws ExtensionException
     * @throws Exception
     *
     * @covers ::__construct
     * @covers ::updateModuleVersion
     */
    public function testSingleCreateVersionFile(): void
    {
        $this->clearMockDirName(
            ['/home/project/last_version/install/version.php' => '/home/project/last_version/install'],
        );
        $this->clearMockIsDir(['/home/project/updates/1.1.0/install' => false]);
        $this->clearMockIsFile(['/home/project/last_version/install/version.php' => true]);

        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $this->clearMockFileExists([
            '/home/project/last_version/install/version.php' => false,
        ]);
        $this->clearMockFileGetContents([]);
        $this->clearMockFilePutContents();
        $addedFiles = [];
        $gitExecutor = self::createMock(VcsExecutorInterface::class);
        $gitExecutor->expects(self::exactly(4))
            ->method('addFile')
            ->willReturnCallback(static function (string $fileName) use (&$addedFiles): void {
                $addedFiles[] = $fileName;
            });
        $gitExecutor->expects(self::once())->method('getFilesSinceTag')
            ->willReturn([]);
        $config = new Config();
        $config->setVcsExecutor($gitExecutor);

        $event = $this->getMockBuilder(Event::class)
            ->setConstructorArgs([EventType::BEFORE_VERSION_SET, '1.1.0'])
            ->getMock();
        $event->expects(self::exactly(2))->method('getData')
            ->willReturnCallback(static function (string $key): mixed {
                return match ($key) {
                    SemanticVersionUpdater::LAST_VERSION_TAG => 'v1.0.0',
                    SemanticVersionUpdater::COMMIT_LIST => self::getCommitCollection(),
                    default => '',
                };
            });

        $listener = new ModuleListener($config, 'vendor.test');
        $listener->handle($event);
        $date = date('Y-m-d');
        self::assertSame(
            <<<PHP
                <?php

                declare(strict_types=1);

                \$arModuleVersion = [
                    'VERSION' => '1.1.0',
                    'VERSION_DATE' => '{$date}',
                ];

                PHP,
            self::$mockFilePutContentsContent['/home/project/last_version/install/version.php'],
            'Wrong version file content',
        );
        self::assertSame([
            '/home/project/last_version/install/version.php',
            '/home/project/updates/1.1.0/updater1.1.0.php',
            '/home/project/updates/1.1.0/description.ru',
            '/home/project/updates/1.1.0/description.en',
        ], $addedFiles, 'Wrong files added to git');
    }

    /**
     * @throws ApplicationException
     * @throws ExtensionException
     * @throws Exception
     *
     * @covers ::normalizePath
     */
    public function testSingleEmptyLang(): void
    {
        $sourcePath = '/src';
        $destinationPath = '/dst';
        $this->clearMockDirName(
            [$destinationPath . '/install/version.php' => [$destinationPath . 'install']],
        );
        $this->clearMockIsDir([$destinationPath . 'install' => false]);
        $this->clearMockIsFile([$destinationPath . '/install/version.php' => true]);

        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $this->clearMockFileExists([$sourcePath . '/install/version.php' => true]);
        $this->clearMockFileGetContents([
            $sourcePath . '/install/version.php' => <<<'PHP'
                <?php
                $arModuleVersion = [
                    'VERSION' => '1.0.0',
                    'VERSION_DATE' => '2022-01-01',
                ];
                PHP,
        ]);
        $this->clearMockFilePutContents();
        $addedFiles = [];
        $gitExecutor = self::createMock(VcsExecutorInterface::class);
        $gitExecutor->expects(self::once())
            ->method('addFile')
            ->willReturnCallback(static function (string $fileName) use (&$addedFiles): void {
                $addedFiles[] = $fileName;
            });
        $gitExecutor->expects(self::once())->method('getFilesSinceTag')
            ->willReturn([]);
        $config = new Config();
        $config->setVcsExecutor($gitExecutor);

        $event = $this->getMockBuilder(Event::class)
            ->setConstructorArgs([EventType::BEFORE_VERSION_SET, '1.1.0'])
            ->getMock();
        $event->expects(self::exactly(2))->method('getData')
            ->willReturnCallback(static function (string $key): mixed {
                return match ($key) {
                    SemanticVersionUpdater::LAST_VERSION_TAG => 'v1.0.0',
                    SemanticVersionUpdater::COMMIT_LIST => self::getCommitCollection(),
                    default => '',
                };
            });

        $listener = new ModuleListener(
            $config,
            'vendor.test',
            sourcePath: ' /src ',
            destinationPath: '  /dst',
            lang: [],
        );
        $listener->handle($event);
        self::assertSame([
            $destinationPath . '/1.1.0/updater1.1.0.php',
        ], $addedFiles, 'Wrong files added to git');
    }

    /**
     * @throws ApplicationException
     * @throws ExtensionException
     * @throws Exception
     *
     * @covers ::__construct
     * @covers ::getCopyDirectories
     * @covers ::getIncludes
     * @covers ::getModuleRelated
     * @covers ::writeDescription
     */
    public function testIncludeFile(): void
    {
        $this->clearMockDirName(
            ['/home/project/last_version/install/version.php' => '/home/project/last_version/install'],
        );
        $this->clearMockIsDir(['/home/project/updates/1.1.0/install' => false]);
        $this->clearMockIsFile(['/home/project/last_version/install/version.php' => true]);

        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $this->clearMockFileExists([
            '/home/project/last_version/install/version.php' => true,
            'file.php' => true,
        ]);
        $this->clearMockFileGetContents([
            'file.php' => '<?php echo "123";',
            '/home/project/last_version/install/version.php' => <<<'PHP'
                <?php
                $arModuleVersion = [
                    'VERSION' => '1.0.0',
                    'VERSION_DATE' => '2022-01-01',
                ];
                PHP,
        ]);
        $this->clearMockFilePutContents();
        $addedFiles = [];
        $gitExecutor = self::createMock(VcsExecutorInterface::class);
        $gitExecutor->expects(self::exactly(1))
            ->method('addFile')
            ->willReturnCallback(static function (string $fileName) use (&$addedFiles): void {
                $addedFiles[] = $fileName;
            });
        $gitExecutor->expects(self::once())->method('getFilesSinceTag')
            ->willReturn([]);
        $config = new Config();
        $config->setVcsExecutor($gitExecutor);

        $event = $this->getMockBuilder(Event::class)
            ->setConstructorArgs([EventType::BEFORE_VERSION_SET, '1.1.0'])
            ->getMock();
        $event->expects(self::exactly(2))->method('getData')
            ->willReturnCallback(static function (string $key): mixed {
                return match ($key) {
                    SemanticVersionUpdater::LAST_VERSION_TAG => 'v1.0.0',
                    SemanticVersionUpdater::COMMIT_LIST => self::getCommitCollection(),
                    default => '',
                };
            });

        $listener = new ModuleListener($config, 'vendor.test', lang: [], includePhpFile: 'file.php');
        $listener->handle($event);
        self::assertSame(
            <<<'PHP'
                <?php

                declare(strict_types=1);

                /**
                * @var CUpdater $updater
                */

                if(IsModuleInstalled('vendor.test')){
                    echo "123";
                }

                PHP,
            self::$mockFilePutContentsContent['/home/project/updates/1.1.0/updater1.1.0.php'],
            'Wrong updater file content',
        );
    }

    /**
     * @throws ApplicationException
     * @throws ExtensionException
     * @throws Exception
     *
     * @covers ::writeDescription
     * @covers ::writeVersionControl
     */
    public function testSingleCustomLang(): void
    {
        $this->clearMockDirName(
            ['/home/project/last_version/install/version.php' => '/home/project/last_version/install'],
        );
        $this->clearMockIsDir(['/home/project/updates/1.1.0/install' => false]);
        $this->clearMockIsFile(['/home/project/last_version/install/version.php' => true]);

        $this->clearMockGetEnv(['COMPOSER' => 'project']);
        $this->clearMockRealPath(['project' => '/home/project'], '');
        $this->clearMockFileExists([
            '/home/project/last_version/install/version.php' => true,
        ]);
        $this->clearMockFileGetContents([
            '/home/project/last_version/install/version.php' => <<<'PHP'
                <?php
                $arModuleVersion = [
                    'VERSION' => '1.0.0',
                    'VERSION_DATE' => '2022-01-01',
                ];
                PHP,
        ]);
        $this->clearMockFilePutContents();
        $addedFiles = [];
        $gitExecutor = self::createMock(VcsExecutorInterface::class);
        $gitExecutor->expects(self::exactly(4))
            ->method('addFile')
            ->willReturnCallback(static function (string $fileName) use (&$addedFiles): void {
                $addedFiles[] = $fileName;
            });
        $gitExecutor->expects(self::once())->method('getFilesSinceTag')
            ->willReturn([]);
        $config = new Config();
        $config->setVcsExecutor($gitExecutor);

        $event = $this->getMockBuilder(Event::class)
            ->setConstructorArgs([EventType::BEFORE_VERSION_SET, '1.1.0'])
            ->getMock();
        $event->expects(self::exactly(2))->method('getData')
            ->willReturnCallback(static function (string $key): mixed {
                return match ($key) {
                    SemanticVersionUpdater::LAST_VERSION_TAG => 'v1.0.0',
                    SemanticVersionUpdater::COMMIT_LIST => self::getCommitCollection(),
                    default => '',
                };
            });

        $listener = new ModuleListener($config, 'vendor.test', lang: ['ru', 'en', 'fr']);
        $listener->handle($event);
        self::assertSame([
            '/home/project/updates/1.1.0/updater1.1.0.php',
            '/home/project/updates/1.1.0/description.ru',
            '/home/project/updates/1.1.0/description.en',
            '/home/project/updates/1.1.0/description.fr',
        ], $addedFiles, 'Wrong files added to git');
    }

    private static function getCommitCollection(): CommitCollection
    {
        $config = new Config();
        $sections = [
            'feat' => new Section('feat', 'Feature', false, [new DefaultRule('feat')], false, false, $config),
        ];

        return new CommitCollection($sections, $sections['feat']);
    }
}
